{"head":{"layout":"Post","comments":true,"date":"2017-10-10","title":"Utiliser Reason avec JavaScript","tags":["reasonml","ocaml","javascript"],"authors":["bloodyowl"],"header":{"linearGradient":null},"description":"Dans un précédent article, on vous présentait une nouvelle syntaxe pour OCaml: ReasonML, elle rend le langage plus accessible en le…"},"body":"<p>Dans un <a href=\"/fr/articles/reason/introduction-reason/\">précédent article</a>, on vous présentait une nouvelle syntaxe pour OCaml: <a href=\"https://reasonml.github.io\">ReasonML</a>, elle rend le langage plus accessible en le rapprochant de JavaScript moderne.</p>\n<p>À l'aide du projet <a href=\"https://bucklescript.github.io/bucklescript/Manual.html\">BuckleScript</a> qui supporte Reason nativement, on peut compiler notre code Reason vers JavaScript très facilement. Le créateur de BuckleScript utilisait à l'origine un autre projet appelé <a href=\"http://ocsigen.org/js_of_ocaml/\">js_of_ocaml</a>. Trouvant qu'il serait possible d'optimiser et de rendre plus lisible le code JavaScript en sortie si le compiler commençait son travail à une étape plus haut niveau (une représentation du programme contenant des informations supplémentaires, alors que js_of_ocaml utilise du bytecode), il propose ce changement à la team js_of_ocaml qui refuse, et décide donc de se lancer dans le projet qui deviendra BuckleScript.</p>\n<p>Pour démarrer un projet avec BuckleScript et Reason, on ouvre son terminal, et c'est parti:</p>\n<p>On installe BuckleScript:</p>\n<pre><code class=\"hljs language-console\">$ npm <span class=\"hljs-keyword\">install</span> -g bs-platform</code></pre>\n<p>On initialise le projet:</p>\n<pre><code class=\"hljs language-console\">$ bsb -init <span class=\"hljs-keyword\">my</span>-app -theme basic-reason</code></pre>\n<p>Hop, votre projet est prêt dans <code>my-app</code>.</p>\n<p>Maintenant la question est: comment est-ce que je peux utiliser du JS dans Reason et vice-versa ?</p>\n<h2 id=\"les-ffi-ou-foreign-function-interface\"><a href=\"#les-ffi-ou-foreign-function-interface\" class=\"phenomic-HeadingAnchor\">#</a>Les FFI (ou Foreign Function Interface)</h2>\n<p>OCaml gère naturellement les <code>FFI</code>, notamment pour appeler des fonctions <code>C</code> lorsqu'il compile vers du code natif.</p>\n<p>BuckleScript vient les overloader pour les adapter à JavaScript.</p>\n<p>Créons une FFI pour la fonction <code>alert</code> :</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-keyword\">external</span> alert : <span class=\"hljs-built_in\">string</span> => <span class=\"hljs-built_in\">unit</span> = <span class=\"hljs-string\">\"\"</span> [@@bs.<span class=\"hljs-keyword\">val</span>];</code></pre>\n<p>On définit:</p>\n<ul>\n<li>une fonction externe nommée <code>alert</code></li>\n<li>qui prend une <code>string</code> et ne retourne <em>rien</em> (ici représenté par la valeur <code>unit</code>)</li>\n<li>qui est une valeur à simplement récupérer (<code>[@@bs.val]</code>)</li>\n</ul>\n<p>Si on regarde le code JavaScript en sortie, c'est vide. En effet, <code>external</code> est un moyen de définir comment accéder à une valeur ainsi que son type. Si en revanche on utilise la function <code>alert</code> dans le module:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-keyword\">external</span> alert : <span class=\"hljs-built_in\">string</span> => <span class=\"hljs-built_in\">unit</span> = <span class=\"hljs-string\">\"\"</span> [@@bs.<span class=\"hljs-keyword\">val</span>];\n\nalert <span class=\"hljs-string\">\"Hello!\"</span>;</code></pre>\n<p>On voit dans l'output que BuckleScript a <em>inliné</em> l'appel de <code>alert</code>, il n'a pas crée de représentation intermédiaire.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE</span>\n<span class=\"hljs-meta\">'use strict'</span>;\n\n\nalert(<span class=\"hljs-string\">\"Hello!\"</span>);\n\n<span class=\"hljs-comment\">/*  Not a pure module */</span></code></pre>\n<p>Maintenant amusons nous à créer des bindings pour jQuery, juste pour le fun:</p>\n<pre><code class=\"hljs language-reason\">/* <span class=\"hljs-type\">On</span> crée un <span class=\"hljs-keyword\">type</span> opaque pour représenter un objet jQuery */\n<span class=\"hljs-keyword\">type</span> jQuery;\n\n/* <span class=\"hljs-type\">On</span> <span class=\"hljs-keyword\">type</span> le <span class=\"hljs-keyword\">module</span> jQuery */\n<span class=\"hljs-keyword\">external</span> jQuery : <span class=\"hljs-built_in\">string</span> => jQuery = <span class=\"hljs-string\">\"jquery\"</span> [@@bs.<span class=\"hljs-keyword\">module</span>];\n\n/* <span class=\"hljs-type\">On</span> <span class=\"hljs-keyword\">type</span> la méthod `on`, <span class=\"hljs-type\">BuckleScript</span> peut naturellement typer\n  le pattern de chaining, assez commun en <span class=\"hljs-type\">JS</span>, à l'aide de l'annotation\n  `bs.send.pipe: <span class=\"hljs-keyword\">type</span>` */\n<span class=\"hljs-keyword\">external</span> on : <span class=\"hljs-built_in\">string</span> => (<span class=\"hljs-type\">Dom</span>.event => <span class=\"hljs-built_in\">unit</span>) => jQuery = <span class=\"hljs-string\">\"\"</span> [@@bs.send.pipe: jQuery];\n\njQuery <span class=\"hljs-string\">\".selector\"</span>\n  |> on <span class=\"hljs-string\">\"click\"</span> (<span class=\"hljs-keyword\">fun</span> _ => alert <span class=\"hljs-string\">\"hey\"</span>);</code></pre>\n<p>Ce qui va nous sortir:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE</span>\n<span class=\"hljs-meta\">'use strict'</span>;\n\n<span class=\"hljs-keyword\">var</span> JQuery = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"jquery\"</span>);\n\nJQuery(<span class=\"hljs-string\">\".selector\"</span>).on(<span class=\"hljs-string\">\"click\"</span>, (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n        alert(<span class=\"hljs-string\">\"hey\"</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">/* () */</span><span class=\"hljs-number\">0</span>;\n      }));\n\n<span class=\"hljs-comment\">/*  Not a pure module */</span></code></pre>\n<p>Comme on peut le constater, le code de sortie ressemble beaucoup à ce qu'on pourrait écrire à la main.</p>\n<p>Pour en savoir un peu plus sur les FFI JavaScript:</p>\n<ul>\n<li><a href=\"https://bucklescript.github.io/bucklescript/Manual.html\">La documentation de BuckleScript</a></li>\n<li><a href=\"https://github.com/reasonml-community\">Les projets de bindings crées par la communauté</a> (ceux nommés <code>bs-{nom-de-lib-js}</code>)</li>\n</ul>\n<h2 id=\"les-objets\"><a href=\"#les-objets\" class=\"phenomic-HeadingAnchor\">#</a>Les objets</h2>\n<p>On peut directement utiliser des objets JavaScript en Reason. Pour accéder à une propriété, on utilise <code>##</code>.</p>\n<pre><code class=\"hljs language-reason\">myJsObject##property</code></pre>\n<p>Ça dépanne, mais au sein de notre code Reason, on préférera bien souvent utiliser des records: ils ont une représentation plus légère et sont par défaut immutables. Pour effectuer une conversion, on procède de la manière suivante:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-keyword\">type</span> jsUser =\n  <span class=\"hljs-type\">Js</span>.t {\n    .\n    id : <span class=\"hljs-built_in\">string</span>,\n    username : <span class=\"hljs-built_in\">string</span>,\n    /* valeur pouvant être null, undefined, ou la valeur */\n    birthdate : <span class=\"hljs-type\">Js</span>.<span class=\"hljs-type\">Null_undefined</span>.t <span class=\"hljs-built_in\">string</span>,\n    /* <span class=\"hljs-string\">\"light\"</span> ou <span class=\"hljs-string\">\"dark\"</span>, les enums sont souvent représentés par des strings en <span class=\"hljs-type\">JS</span> */\n    theme : <span class=\"hljs-built_in\">string</span>\n  };\n\n/* <span class=\"hljs-type\">En</span> <span class=\"hljs-type\">Reason</span>, les enums sont représentés par des variants */\n<span class=\"hljs-keyword\">type</span> theme =\n  | <span class=\"hljs-type\">Light</span>\n  | <span class=\"hljs-type\">Dark</span>;\n\n<span class=\"hljs-keyword\">type</span> user = {\n  id: <span class=\"hljs-built_in\">string</span>,\n  username: <span class=\"hljs-built_in\">string</span>,\n  /* pas de null ou undefined, on utilise un <span class=\"hljs-keyword\">type</span> <span class=\"hljs-built_in\">option</span> */\n  birthdate: <span class=\"hljs-built_in\">option</span> <span class=\"hljs-built_in\">string</span>,\n  theme\n};\n\n/* une fonction de transformation <span class=\"hljs-type\">JS</span> -> <span class=\"hljs-type\">Reason</span> */\n<span class=\"hljs-keyword\">let</span> fromJs jsUser => {\n  id: jsUser##id,\n  username: jsUser##username,\n  /* <span class=\"hljs-type\">BuckleScript</span> propose des helpers pour les conversions */\n  birthdate: <span class=\"hljs-type\">Js</span>.<span class=\"hljs-type\">Null_undefined</span>.to_opt jsUser##birthdate,\n  theme:\n    switch jsUser##theme {\n    | <span class=\"hljs-string\">\"dark\"</span> => <span class=\"hljs-type\">Dark</span>\n    | <span class=\"hljs-string\">\"light\"</span>\n    /* <span class=\"hljs-type\">On</span> match une chaîne de caractère, le match n'est pas exhaustif,\n         on doit donc définir la valeur de fallback (par defaut) à l'aide\n         de `_`\n       */\n    | _ => <span class=\"hljs-type\">Light</span>\n    }\n};\n\n/* <span class=\"hljs-type\">Pour</span> créer un objet <span class=\"hljs-type\">JS</span> en <span class=\"hljs-type\">Reason</span>, il suffit de l'écrire comme un\n     record, mais avec des clés entre quotes, comme du <span class=\"hljs-type\">JSON</span>.\n   */\n<span class=\"hljs-keyword\">let</span> toJs user => {\n  <span class=\"hljs-string\">\"id\"</span>: user.id,\n  <span class=\"hljs-string\">\"username\"</span>: user.username,\n  <span class=\"hljs-string\">\"birthdate\"</span>: <span class=\"hljs-type\">Js</span>.<span class=\"hljs-type\">Null_undefined</span>.from_opt user.birthdate,\n  <span class=\"hljs-string\">\"theme\"</span>:\n    switch user.theme {\n    | <span class=\"hljs-type\">Light</span> => <span class=\"hljs-string\">\"light\"</span>\n    | <span class=\"hljs-type\">Dark</span> => <span class=\"hljs-string\">\"dark\"</span>\n    }\n};</code></pre>\n<p>Le code en sortie:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE</span>\n<span class=\"hljs-meta\">'use strict'</span>;\n\n<span class=\"hljs-keyword\">var</span> Js_primitive      = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"bs-platform/lib/js/js_primitive.js\"</span>);\n<span class=\"hljs-keyword\">var</span> Js_null_undefined = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"bs-platform/lib/js/js_null_undefined.js\"</span>);\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fromJs</span>(<span class=\"hljs-params\">jsUser</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> match = jsUser.theme;\n  <span class=\"hljs-keyword\">var</span> tmp;\n  <span class=\"hljs-keyword\">switch</span> (match) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"dark\"</span> :\n        tmp = <span class=\"hljs-comment\">/* Dark */</span><span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"light\"</span> :\n        tmp = <span class=\"hljs-comment\">/* Light */</span><span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">default</span>:\n      tmp = <span class=\"hljs-comment\">/* Light */</span><span class=\"hljs-number\">0</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">/* record */</span>[\n          <span class=\"hljs-comment\">/* id */</span>jsUser.id,\n          <span class=\"hljs-comment\">/* username */</span>jsUser.username,\n          <span class=\"hljs-comment\">/* birthdate */</span>Js_primitive.null_undefined_to_opt(jsUser.birthdate),\n          <span class=\"hljs-comment\">/* theme */</span>tmp\n        ];\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">toJs</span>(<span class=\"hljs-params\">user</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> match = user[<span class=\"hljs-comment\">/* theme */</span><span class=\"hljs-number\">3</span>];\n  <span class=\"hljs-keyword\">return</span> {\n          <span class=\"hljs-attr\">id</span>: user[<span class=\"hljs-comment\">/* id */</span><span class=\"hljs-number\">0</span>],\n          <span class=\"hljs-attr\">username</span>: user[<span class=\"hljs-comment\">/* username */</span><span class=\"hljs-number\">1</span>],\n          <span class=\"hljs-attr\">birthdate</span>: Js_null_undefined.from_opt(user[<span class=\"hljs-comment\">/* birthdate */</span><span class=\"hljs-number\">2</span>]),\n          <span class=\"hljs-attr\">theme</span>: match !== <span class=\"hljs-number\">0</span> ? <span class=\"hljs-string\">\"dark\"</span> : <span class=\"hljs-string\">\"light\"</span>\n        };\n}\n\nexports.fromJs = fromJs;\nexports.toJs   = toJs;\n<span class=\"hljs-comment\">/* No side effect */</span></code></pre>\n<h2 id=\"les-standard-libs\"><a href=\"#les-standard-libs\" class=\"phenomic-HeadingAnchor\">#</a>Les standard-libs</h2>\n<p>Si le besoin s'en fait sentir, BuckleScript propose naturellement la stdlib de JavaScript.</p>\n<pre><code class=\"hljs language-reason\">let myArray = [|<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>|];\n\nmyArray\n  |> Js.Array.map (<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">item</span></span> => item * <span class=\"hljs-number\">2</span>)\n  |> Js.Array.reduce (<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">acc</span></span> item => acc + item) <span class=\"hljs-number\">0</span>;</code></pre>\n<p>vous sortira:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE</span>\n<span class=\"hljs-meta\">'use strict'</span>;\n\n\n<span class=\"hljs-keyword\">var</span> myArray = <span class=\"hljs-comment\">/* array */</span>[\n  <span class=\"hljs-number\">1</span>,\n  <span class=\"hljs-number\">2</span>,\n  <span class=\"hljs-number\">3</span>,\n  <span class=\"hljs-number\">4</span>,\n  <span class=\"hljs-number\">5</span>\n];\n\nmyArray.map((<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) </span>{\n          <span class=\"hljs-keyword\">return</span> (item &#x3C;&#x3C; <span class=\"hljs-number\">1</span>);\n        })).reduce((<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">acc, item</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> acc + item | <span class=\"hljs-number\">0</span>;\n      }), <span class=\"hljs-number\">0</span>);\n\nexports.myArray = myArray;\n<span class=\"hljs-comment\">/*  Not a pure module */</span></code></pre>\n<h2 id=\"la-technique-bourrin\"><a href=\"#la-technique-bourrin\" class=\"phenomic-HeadingAnchor\">#</a>La technique bourrin</h2>\n<p>Pour les cas extrêmes ou vous voulez juste balancer une fonction JS, vous pouvez:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-comment\">/* %bs.raw pour une expression, %%bs.raw pour un bloc de code arbitraire */</span>\n<span class=\"hljs-keyword\">let</span> log: <span class=\"hljs-function\"><span class=\"hljs-params\">string</span> =></span> unit = [%bs.raw {|\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(a);\n  }\n|}];\n\nlog <span class=\"hljs-string\">\"ok\"</span>;</code></pre>\n<p>qui vous sort un joli:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE</span>\n<span class=\"hljs-meta\">'use strict'</span>;\n\n<span class=\"hljs-keyword\">var</span> Curry = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"bs-platform/lib/js/curry.js\"</span>);\n\n<span class=\"hljs-keyword\">var</span> log = (\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(a);\n  }\n);\n\nCurry._1(log, <span class=\"hljs-string\">\"ok\"</span>);\n\nexports.log = log;\n<span class=\"hljs-comment\">/* log Not a pure module */</span></code></pre>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" class=\"phenomic-HeadingAnchor\">#</a>Conclusion</h2>\n<p>OCaml peut en grande majorité être compilé en JavaScript très simple, parce qu'il partage beaucoup de concepts avec ce dernier. Il est assez simple de créer des ponts entre les deux langages à l'aide des FFI. L'énorme avantage de cette feature, c'est que l'on peut commencer à utiliser Reason incrémentalement sur son projet sans avoir à tout réécrire d'un coup.</p>\n<p>Bisous bisous.</p>\n","rawBody":"\nDans un [précédent article](/fr/articles/reason/introduction-reason/), on vous présentait une nouvelle syntaxe pour OCaml: [ReasonML](https://reasonml.github.io), elle rend le langage plus accessible en le rapprochant de JavaScript moderne.\n\nÀ l'aide du projet [BuckleScript](https://bucklescript.github.io/bucklescript/Manual.html) qui supporte Reason nativement, on peut compiler notre code Reason vers JavaScript très facilement. Le créateur de BuckleScript utilisait à l'origine un autre projet appelé [js_of_ocaml](http://ocsigen.org/js_of_ocaml/). Trouvant qu'il serait possible d'optimiser et de rendre plus lisible le code JavaScript en sortie si le compiler commençait son travail à une étape plus haut niveau (une représentation du programme contenant des informations supplémentaires, alors que js_of_ocaml utilise du bytecode), il propose ce changement à la team js_of_ocaml qui refuse, et décide donc de se lancer dans le projet qui deviendra BuckleScript.\n\nPour démarrer un projet avec BuckleScript et Reason, on ouvre son terminal, et c'est parti:\n\nOn installe BuckleScript:\n\n```console\n$ npm install -g bs-platform\n```\n\nOn initialise le projet:\n\n```console\n$ bsb -init my-app -theme basic-reason\n```\n\nHop, votre projet est prêt dans `my-app`.\n\nMaintenant la question est: comment est-ce que je peux utiliser du JS dans Reason et vice-versa ?\n\n## Les FFI (ou Foreign Function Interface)\n\nOCaml gère naturellement les `FFI`, notamment pour appeler des fonctions `C` lorsqu'il compile vers du code natif.\n\nBuckleScript vient les overloader pour les adapter à JavaScript.\n\nCréons une FFI pour la fonction `alert` :\n\n```reason\nexternal alert : string => unit = \"\" [@@bs.val];\n```\n\nOn définit:\n\n- une fonction externe nommée `alert`\n- qui prend une `string` et ne retourne *rien* (ici représenté par la valeur `unit`)\n- qui est une valeur à simplement récupérer (`[@@bs.val]`)\n\nSi on regarde le code JavaScript en sortie, c'est vide. En effet, `external` est un moyen de définir comment accéder à une valeur ainsi que son type. Si en revanche on utilise la function `alert` dans le module:\n\n```reason\nexternal alert : string => unit = \"\" [@@bs.val];\n\nalert \"Hello!\";\n```\n\nOn voit dans l'output que BuckleScript a *inliné* l'appel de `alert`, il n'a pas crée de représentation intermédiaire.\n\n```javascript\n// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE\n'use strict';\n\n\nalert(\"Hello!\");\n\n/*  Not a pure module */\n```\n\nMaintenant amusons nous à créer des bindings pour jQuery, juste pour le fun:\n\n```reason\n/* On crée un type opaque pour représenter un objet jQuery */\ntype jQuery;\n\n/* On type le module jQuery */\nexternal jQuery : string => jQuery = \"jquery\" [@@bs.module];\n\n/* On type la méthod `on`, BuckleScript peut naturellement typer\n  le pattern de chaining, assez commun en JS, à l'aide de l'annotation\n  `bs.send.pipe: type` */\nexternal on : string => (Dom.event => unit) => jQuery = \"\" [@@bs.send.pipe: jQuery];\n\njQuery \".selector\"\n  |> on \"click\" (fun _ => alert \"hey\");\n```\n\nCe qui va nous sortir:\n\n```javascript\n// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE\n'use strict';\n\nvar JQuery = require(\"jquery\");\n\nJQuery(\".selector\").on(\"click\", (function () {\n        alert(\"hey\");\n        return /* () */0;\n      }));\n\n/*  Not a pure module */\n```\n\nComme on peut le constater, le code de sortie ressemble beaucoup à ce qu'on pourrait écrire à la main.\n\nPour en savoir un peu plus sur les FFI JavaScript:\n\n- [La documentation de BuckleScript](https://bucklescript.github.io/bucklescript/Manual.html)\n- [Les projets de bindings crées par la communauté](https://github.com/reasonml-community) (ceux nommés `bs-{nom-de-lib-js}`)\n\n## Les objets\n\nOn peut directement utiliser des objets JavaScript en Reason. Pour accéder à une propriété, on utilise `##`.\n\n```reason\nmyJsObject##property\n```\n\nÇa dépanne, mais au sein de notre code Reason, on préférera bien souvent utiliser des records: ils ont une représentation plus légère et sont par défaut immutables. Pour effectuer une conversion, on procède de la manière suivante:\n\n```reason\ntype jsUser =\n  Js.t {\n    .\n    id : string,\n    username : string,\n    /* valeur pouvant être null, undefined, ou la valeur */\n    birthdate : Js.Null_undefined.t string,\n    /* \"light\" ou \"dark\", les enums sont souvent représentés par des strings en JS */\n    theme : string\n  };\n\n/* En Reason, les enums sont représentés par des variants */\ntype theme =\n  | Light\n  | Dark;\n\ntype user = {\n  id: string,\n  username: string,\n  /* pas de null ou undefined, on utilise un type option */\n  birthdate: option string,\n  theme\n};\n\n/* une fonction de transformation JS -> Reason */\nlet fromJs jsUser => {\n  id: jsUser##id,\n  username: jsUser##username,\n  /* BuckleScript propose des helpers pour les conversions */\n  birthdate: Js.Null_undefined.to_opt jsUser##birthdate,\n  theme:\n    switch jsUser##theme {\n    | \"dark\" => Dark\n    | \"light\"\n    /* On match une chaîne de caractère, le match n'est pas exhaustif,\n         on doit donc définir la valeur de fallback (par defaut) à l'aide\n         de `_`\n       */\n    | _ => Light\n    }\n};\n\n/* Pour créer un objet JS en Reason, il suffit de l'écrire comme un\n     record, mais avec des clés entre quotes, comme du JSON.\n   */\nlet toJs user => {\n  \"id\": user.id,\n  \"username\": user.username,\n  \"birthdate\": Js.Null_undefined.from_opt user.birthdate,\n  \"theme\":\n    switch user.theme {\n    | Light => \"light\"\n    | Dark => \"dark\"\n    }\n};\n```\n\nLe code en sortie:\n\n```javascript\n// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE\n'use strict';\n\nvar Js_primitive      = require(\"bs-platform/lib/js/js_primitive.js\");\nvar Js_null_undefined = require(\"bs-platform/lib/js/js_null_undefined.js\");\n\nfunction fromJs(jsUser) {\n  var match = jsUser.theme;\n  var tmp;\n  switch (match) {\n    case \"dark\" :\n        tmp = /* Dark */1;\n        break;\n    case \"light\" :\n        tmp = /* Light */0;\n        break;\n    default:\n      tmp = /* Light */0;\n  }\n  return /* record */[\n          /* id */jsUser.id,\n          /* username */jsUser.username,\n          /* birthdate */Js_primitive.null_undefined_to_opt(jsUser.birthdate),\n          /* theme */tmp\n        ];\n}\n\nfunction toJs(user) {\n  var match = user[/* theme */3];\n  return {\n          id: user[/* id */0],\n          username: user[/* username */1],\n          birthdate: Js_null_undefined.from_opt(user[/* birthdate */2]),\n          theme: match !== 0 ? \"dark\" : \"light\"\n        };\n}\n\nexports.fromJs = fromJs;\nexports.toJs   = toJs;\n/* No side effect */\n```\n\n## Les standard-libs\n\nSi le besoin s'en fait sentir, BuckleScript propose naturellement la stdlib de JavaScript.\n\n```reason\nlet myArray = [|1, 2, 3, 4, 5|];\n\nmyArray\n  |> Js.Array.map (fun item => item * 2)\n  |> Js.Array.reduce (fun acc item => acc + item) 0;\n```\n\nvous sortira:\n\n```javascript\n// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE\n'use strict';\n\n\nvar myArray = /* array */[\n  1,\n  2,\n  3,\n  4,\n  5\n];\n\nmyArray.map((function (item) {\n          return (item << 1);\n        })).reduce((function (acc, item) {\n        return acc + item | 0;\n      }), 0);\n\nexports.myArray = myArray;\n/*  Not a pure module */\n```\n\n## La technique bourrin\n\nPour les cas extrêmes ou vous voulez juste balancer une fonction JS, vous pouvez:\n\n```reason\n/* %bs.raw pour une expression, %%bs.raw pour un bloc de code arbitraire */\nlet log: string => unit = [%bs.raw {|\n  function (a) {\n    console.log(a);\n  }\n|}];\n\nlog \"ok\";\n```\n\nqui vous sort un joli:\n\n```javascript\n// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE\n'use strict';\n\nvar Curry = require(\"bs-platform/lib/js/curry.js\");\n\nvar log = (\n  function (a) {\n    console.log(a);\n  }\n);\n\nCurry._1(log, \"ok\");\n\nexports.log = log;\n/* log Not a pure module */\n```\n\n## Conclusion\n\nOCaml peut en grande majorité être compilé en JavaScript très simple, parce qu'il partage beaucoup de concepts avec ce dernier. Il est assez simple de créer des ponts entre les deux langages à l'aide des FFI. L'énorme avantage de cette feature, c'est que l'on peut commencer à utiliser Reason incrémentalement sur son projet sans avoir à tout réécrire d'un coup.\n\nBisous bisous.\n","__filename":"fr/articles/reason/interop/index.md","__url":"/fr/articles/reason/interop/","__resourceUrl":"/fr/articles/reason/interop/index.html","__dataUrl":"/fr/articles/reason/interop/index.html.95c5d6497996cce25997e1d4aec14335.json"}