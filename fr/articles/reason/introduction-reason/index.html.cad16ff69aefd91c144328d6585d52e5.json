{"head":{"layout":"Post","comments":true,"date":"2017-10-02","title":"Introduction √† ReasonML (ou pourquoi j'ai arr√™t√© d'utiliser JavaScript)","tags":["reasonml","ocaml","javascript"],"authors":["bloodyowl"],"header":{"image":"index.png","linearGradient":null},"description":"Les bugs c'est chiant, surtout quand on sait qu'on aurait pu les √©viter. Avec JavaScript, c'est plus facile d'en avoir que de les √©viter.‚Ä¶"},"body":"<p>Les bugs c'est chiant, surtout quand on sait qu'on aurait pu les √©viter. Avec JavaScript, c'est plus facile d'en avoir que de les √©viter.</p>\n<p>JavaScript, on ne peut pas y √©chapper parce que c'est partout, parce que c'est le langage de programmation le plus utilis√© sur Terre, et parce que c'est le seul truc qui (pour l'instant) tourne nativement dans le navigateur. Et puis c'est pas si mal, c'est facile de l'apprendre en bidouillant un peu, c'est tr√®s permissif et pas trop frustrant pour d√©buter.</p>\n<p>Le probl√®me c'est que c'est facile d'en faire, mais c'est tr√®s dur d'en faire <strong>bien</strong> (moins que CSS, mais quand m√™me). On s'est tous d√©j√† retrouv√© avec <code>undefined is not a function</code>, <code>null is not an object</code> ou un bon gros <code>[object Object]</code> qui tra√Æne dans la console.</p>\n<h2 id=\"pourquoi-est-ce-que-cest-comme-√ßa-\"><a href=\"#pourquoi-est-ce-que-cest-comme-%C3%A7a-\" class=\"phenomic-HeadingAnchor\">#</a>Pourquoi est-ce que c'est comme √ßa ?</h2>\n<p>JavaScript est un langage dynamiquement et faiblement typ√©, ce qui veut dire :</p>\n<ul>\n<li>qu'une fonction ne sait pas ce qu'elle prend ou retourne comme type\nd'arguments, c'est √† vous de g√©rer</li>\n<li>que le programme n'en a aucune id√©e non plus tant qu'il n'execute pas\nla portion de code</li>\n</ul>\n<p>Tout √ßa fait qu'il est tr√®s difficile de faire confiance √† du code JavaScript.</p>\n<figure>\n<img src=\"./js.png\" alt=\"js\" />\n<figcaption>Source: MIT</figcaption>\n</figure>\n<p>Il existe Flow et TypeScript (dont on a parl√© dans un <a href=\"/fr/articles/js/flow/\">pr√©c√©dent article</a> et un <a href=\"fr/articles/podcast/3/\">podcast</a>), deux projets qui permettent d'apporter du typage statique pour s√©curiser son code. Ils contraignent votre usage de JavaScript, mais devront toujours se battre contre sa permissivit√©.</p>\n<p>√áa revient au final √† coller des rustines sur vos pneus avant d'aller rouler sur des clous, √ßa va vous prot√©ger un peu, mais √ßa reste de base pas bien malin d'aller rouler sur des clous.</p>\n<p>Il existe des langages qui ont la judicieuse id√©e de balayer la route pour virer les clous avant d'y aller : les langages typ√©s fortement et statiquement (10 points pour Gryffondor pour cette m√©taphore fil√©e).</p>\n<p>OCaml est un de ces langages. Il est de la famille ML et a √©t√© cr√©√© en France dans les ann√©es 90. Il est √† peu pr√®s aussi √¢g√© que JavaScript mais est beaucoup plus sage. Il est certes fortement et statiquement typ√©, mais il inf√®re la plupart des types du programme (ce qui veut dire que vous n'avez pas √† renseigner les types partout, il va l'extrapoler d√®s qu'il le peut). En bonus, il poss√®de de <a href=\"https://ocaml.org/learn/tutorials/comparison_of_standard_containers.html\">bonnes data-structures</a>.</p>\n<p>Seulement voil√†, OCaml, comme beaucoup de langages fonctionnels n'a pas vraiment mis l'accent sur l'accessibilit√© pour les d√©butants, et a une syntaxe qu'on peut pour le moins qualifier de pas tr√®s friendly: elle n'a rien de bien mal, mais mettez quelqu'un qui vient de JS/PHP/Java devant, √ßa va pas lui causer des masses:</p>\n<pre><code class=\"hljs language-ocaml\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">rec</span> qsort = <span class=\"hljs-keyword\">fun</span> <span class=\"hljs-keyword\">value</span> ->\n  <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">value</span> <span class=\"hljs-keyword\">with</span>\n   | <span class=\"hljs-literal\">[]</span> -> <span class=\"hljs-literal\">[]</span>\n   | pivot :: rest ->\n       <span class=\"hljs-keyword\">let</span> is_less x = x &#x3C; pivot <span class=\"hljs-keyword\">in</span>\n       <span class=\"hljs-keyword\">let</span> left, right = <span class=\"hljs-type\">List</span>.partition is_less rest <span class=\"hljs-keyword\">in</span>\n       qsort left @ [pivot] @ qsort right;;</code></pre>\n<figure>\n<img src=\"./giphy.gif\" alt=\"\" />\n<figcaption>fig. 1: dev JS devant du code OCaml</figcaption>\n</figure>\n<p>C'est l√† qu'intervient Reason, un projet initi√© par <a href=\"https://twitter.com/jordwalke\">le cr√©ateur de React</a>. Les premi√®res it√©rations de React √©taient d'ailleurs cod√©es dans un langage cousin de OCaml, le SML.</p>\n<p>C'est en gros:</p>\n<ul>\n<li>OCaml</li>\n<li>avec une syntaxe <em>beginner-friendly</em></li>\n<li>avec un tooling le rendant plus simple √† utiliser</li>\n<li>qui peut compiler vers JavaScript et de multiples plateformes</li>\n</ul>\n<p>Avec son type system, OCaml propose un langage <em>safe-by-design</em>, chose que m√™me avec une palanqu√©e d'outils, on ne peut pas atteindre avec JavaScript.</p>\n<p>Le langage propose par d√©faut une approche fonctionnelle et immutable, mais permet cependant de choisir d'utiliser des structures mutables et de l'orient√© objet au besoin.</p>\n<h2 id=\"le-langage\"><a href=\"#le-langage\" class=\"phenomic-HeadingAnchor\">#</a>Le langage</h2>\n<p>Reason comporte plus de types de primitifs que JavaScript:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-comment\">/* pas un gros \"number\" fourre tout, magique */</span>\n<span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">/* int */</span>\n<span class=\"hljs-number\">1.0</span> <span class=\"hljs-comment\">/* float */</span>\n<span class=\"hljs-comment\">/* un caract√®re est d'un type diff√©rent de string */</span>\n<span class=\"hljs-string\">\"foo\"</span> <span class=\"hljs-comment\">/* string */</span>\n'a' <span class=\"hljs-comment\">/* char */</span>\n<span class=\"hljs-comment\">/* on trouve list ET array, chacun peut √™tre utilis√© pour diff√©rents cas */</span>\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>] <span class=\"hljs-comment\">/* list */</span>\n[| <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> |] <span class=\"hljs-comment\">/* array */</span>\n<span class=\"hljs-comment\">/* pas de null, mais des valeurs de type `option` qui contiennent\n  soit une valeur, soit rien */</span>\nSome <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">/* option int */</span>\nNone <span class=\"hljs-comment\">/* option int */</span></code></pre>\n<p>Puisqu'il est fortement typ√©, il est impossible de mixer les types comme en JavaScript, vous devrez obligatoirement les convertir:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1.0</span>;\n<span class=\"hljs-comment\">/* Error:\n  This expression has type int but an expression was expected of type float */</span>\n<span class=\"hljs-number\">1</span> + int_of_float <span class=\"hljs-number\">1.0</span>;\n<span class=\"hljs-comment\">/* - : int = 2 */</span></code></pre>\n<p>La plupart des op√©rations de transformations de type primitifs vers un autre sont accessibles dans le module <code>Pervasives</code> qui contient plein de petits utilitaires bien pratiques. Toutes les fonctions de ce module sont accessibles directement dans n'importe quel de vos fichiers.</p>\n<p>Les fonctions de Reason sont beaucoup plus puissantes qu'en JavaScript:</p>\n<pre><code class=\"hljs language-reason\">let <span class=\"hljs-keyword\">add </span>a <span class=\"hljs-keyword\">b </span>=> a + <span class=\"hljs-keyword\">b;\n</span><span class=\"hljs-comment\">/* int => int => int */</span>\n<span class=\"hljs-keyword\">add </span><span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span><span class=\"hljs-comment\">;</span>\n<span class=\"hljs-comment\">/* 3 */</span>\n<span class=\"hljs-keyword\">add </span><span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span>.<span class=\"hljs-number\">0</span><span class=\"hljs-comment\">;</span>\n<span class=\"hljs-comment\">/* This expression has type float but an expression was expected of type int */</span>\n\n<span class=\"hljs-comment\">/* Les fonctions sont \"auto-curried\", ce qui signifie qu'une fonction\n   qui n'a pas re√ßu tous ses param√®tres retourne une nouvelle fonction\n  qui va recevoir les param√®tres manquants */</span>\nlet <span class=\"hljs-keyword\">addOne </span>= <span class=\"hljs-keyword\">add </span><span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span>\n<span class=\"hljs-comment\">/* int => int */</span>\n\n<span class=\"hljs-comment\">/* Les fonctions peuvent avoir des param√®tres nomm√©s, optionnels et avec des valeurs par d√©faut */</span>\nlet sayHi ::name ::punct=<span class=\"hljs-string\">\"!\"</span> () => <span class=\"hljs-string\">\"Hello \"</span> ^ name ^ punct<span class=\"hljs-comment\">;</span>\n<span class=\"hljs-comment\">/* name::string => string */</span>\nsayHi name::<span class=\"hljs-string\">\"you\"</span> ()<span class=\"hljs-comment\">;</span>\n<span class=\"hljs-comment\">/* \"Hello you!\" */</span>\n<span class=\"hljs-comment\">/* L'ordre des arguments nomm√©s n'a pas d'importance*/</span>\nsayHi punct::<span class=\"hljs-string\">\"?\"</span> name::<span class=\"hljs-string\">\"you\"</span>  ()<span class=\"hljs-comment\">;</span>\n<span class=\"hljs-comment\">/* \"Hello you?\" */</span></code></pre>\n<p>Pour d√©finir l'√©quivalent d'un <em>plain-object</em> JavaScript en Reason, on utilise des records:</p>\n<pre><code class=\"hljs language-reason\">/* On doit typer les records */\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-keyword\">user</span> <span class=\"hljs-title\">= {\n  username</span>: <span class=\"hljs-keyword\">string</span>,\n  age: int\n};\n\n/* Les records ont un nombre de cl√©s fini, vous <span class=\"hljs-keyword\">ne</span> pouvez pas en\n  ommettre une ou en mettre une en trop */\nlet <span class=\"hljs-keyword\">user</span> <span class=\"hljs-title\">= { username</span>: <span class=\"hljs-string\">\"Bob\"</span> };\n/* Error: Some record fields are undefined: age */\n\nlet <span class=\"hljs-keyword\">user</span> <span class=\"hljs-title\">= { username</span>: <span class=\"hljs-string\">\"Bob\"</span>, age: <span class=\"hljs-number\">20</span> };\n\n/* Les records sont immutables par d√©faut */\nlet olderUser = {...user, age: user.age + <span class=\"hljs-number\">1</span> };</code></pre>\n<p>Reason poss√®de un syst√®me de module tr√®s puissant: par d√©faut, chaque fichier de votre codebase est un module, mais vous pouvez √©galement d√©clarer des modules <em>dans</em> un module.</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-keyword\">module</span> User = {\n  type t = {\n    id: string,\n    username: string,\n    email: option string\n  };\n  <span class=\"hljs-keyword\">let</span> make ::id ::username ::email => {id, username, email};\n  <span class=\"hljs-keyword\">let</span> sayHi user => <span class=\"hljs-string\">\"Hello \"</span> ^ user.username ^ <span class=\"hljs-string\">\"!\"</span>;\n};\n\n<span class=\"hljs-comment\">/* Pour utiliser un module, tapez son nom, tout simplement */</span>\nUser.make id::<span class=\"hljs-string\">\"0\"</span> username::<span class=\"hljs-string\">\"bloodyowl\"</span> email::None\n  <span class=\"hljs-comment\">/* (ah oui, le pipe existe d√©j√† ici, pas besoin d'attendre ES2050)*/</span>\n  |> User.sayHi\n  |> print_endline;\n<span class=\"hljs-comment\">/* \"Hello bloodyowl\" */</span>\n\n<span class=\"hljs-comment\">/* On peut √©galement rendre toutes les valeurs d'un module accessibles localement */</span>\nUser.(\n  make id::<span class=\"hljs-string\">\"0\"</span> username::<span class=\"hljs-string\">\"bloodyowl\"</span> email::None\n    |> sayHi\n    |> print_endline\n);\n\n<span class=\"hljs-comment\">/* Carr√©ment les rendre accessibles globalement dans le module */</span>\nopen User;\n\nmake id::<span class=\"hljs-string\">\"0\"</span> username::<span class=\"hljs-string\">\"bloodyowl\"</span> email::None\n  |> sayHi\n  |> print_endline;\n\n<span class=\"hljs-comment\">/* Ou m√™me √©tendre un module statiquement et proprement,\n  √ßa vous parle √ßa, Prototype et MooTools ?! */</span>\n<span class=\"hljs-keyword\">module</span> UserThatCanSayBye = {\n  include User;\n  <span class=\"hljs-keyword\">let</span> sayBye user => <span class=\"hljs-string\">\"Bye \"</span> ^ user.username ^ <span class=\"hljs-string\">\"!\"</span>;\n};</code></pre>\n<p>Il existe √©galement des functors, qui sont des sortes de fonctions retournant des modules √† partir d'autres modules, mais on ne l'abordera pas dans cet article.</p>\n<p>Reason poss√®de √©galement des variants, il s'agit de types pouvant avoir diff√©rents cas. Prenons l'exemple d'un message de chat:</p>\n<pre><code class=\"hljs language-reason\">type <span class=\"hljs-built_in\">image</span> = {url: <span class=\"hljs-keyword\">string</span>, <span class=\"hljs-built_in\">width</span>: <span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">height</span>: <span class=\"hljs-keyword\">int</span>};\n\n<span class=\"hljs-comment\">/* chaque cas du variant peut prendre des param√®tres */</span>\ntype message =\n  | <span class=\"hljs-keyword\">String</span> <span class=\"hljs-keyword\">string</span> <span class=\"hljs-comment\">/* soit une cha√Æne de caract√®res */</span>\n  | Image <span class=\"hljs-built_in\">image</span> <span class=\"hljs-comment\">/* soit une image */</span>\n  | Emoji <span class=\"hljs-keyword\">string</span>; <span class=\"hljs-comment\">/* soit un gros emoji */</span>\n\nlet stringMessage = <span class=\"hljs-keyword\">String</span> <span class=\"hljs-string\">\"Hello\"</span>; <span class=\"hljs-comment\">/* On cr√©e la valeur avec son constructeur */</span>\nlet imageMessage = Image {url: <span class=\"hljs-string\">\"https://fakeimg.pl/300x300\"</span>, <span class=\"hljs-built_in\">width</span>: <span class=\"hljs-number\">300</span>, <span class=\"hljs-built_in\">height</span>: <span class=\"hljs-number\">300</span>};\nlet emojiMessage = Emoji {js|üê´|js}; <span class=\"hljs-comment\">/* Quand la string contient de caract√®res unicode,\n  on doit utiliser {js|votre string|js} */</span></code></pre>\n<p>Ici, notre type <code>message</code> est bien d√©limit√©, et ses valeurs ne peuvent √™tre que celles que l'on a d√©fini.</p>\n<p>Pour utiliser les valeurs d'un variant, on peut les extraire √† l'aide de <code>switch</code>, qui va <em>pattern-matcher</em> pour nous permettre d'identifier et d'extraire les valeurs.</p>\n<pre><code class=\"hljs language-reason\">/* <span class=\"hljs-type\">Petit</span> bonus, l'exemple utilise <span class=\"hljs-type\">ReasonReact</span>, mais on d√©taillera √ßa dans un prochain article */\n<span class=\"hljs-keyword\">let</span> component = <span class=\"hljs-type\">ReasonReact</span>.statelessComponent <span class=\"hljs-string\">\"ChatMessage\"</span>;\n\n<span class=\"hljs-keyword\">let</span> make ::message _children => {\n  ...component,\n  render: <span class=\"hljs-keyword\">fun</span> _ => {\n    &#x3C;div>\n      (switch message {\n        | <span class=\"hljs-type\">String</span> <span class=\"hljs-keyword\">value</span> => <span class=\"hljs-type\">ReasonReact</span>.stringToElement <span class=\"hljs-keyword\">value</span>\n        | <span class=\"hljs-type\">Image</span> {url: src, width, height} => &#x3C;img width height src />\n        /* <span class=\"hljs-type\">Si</span> par m√©garde j'oublie un cas possible dans un switch, je vais avoir un joli warning du\n          compiler qui me dira:\n            <span class=\"hljs-type\">This</span> pattern-matching is not exhaustive.\n            <span class=\"hljs-type\">Here</span> is an example <span class=\"hljs-keyword\">of</span> a <span class=\"hljs-keyword\">value</span> that is not matched:\n              <span class=\"hljs-type\">Emoji</span>\n        */\n        | <span class=\"hljs-type\">Emoji</span> <span class=\"hljs-keyword\">value</span> =>\n          &#x3C;div style=(<span class=\"hljs-type\">ReactDOMRe</span>.<span class=\"hljs-type\">Style</span>.make fontSize::<span class=\"hljs-string\">\"40px\"</span> <span class=\"hljs-literal\">()</span>)>\n            (<span class=\"hljs-type\">ReasonReact</span>.stringToElement <span class=\"hljs-keyword\">value</span>)\n          &#x3C;/div>\n      })\n    &#x3C;/div>\n  }\n};</code></pre>\n<p>En Reason, les <em>let bindings</em> ont automatiquement le block parent comme scope, on peut du coup √©crire des choses comme ceci :</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">value</span> = {\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">a</span> = <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">b</span> = <span class=\"hljs-number\">2</span>;\n  a + b; <span class=\"hljs-comment\">/* la derni√®re expression est toujours retourn√©e par d√©faut */</span>\n};\n<span class=\"hljs-comment\">/* let value : int = 3 */</span>\na\n<span class=\"hljs-comment\">/* Error: Unbound value a */</span>                                                 </code></pre>\n<p>Voil√† pour l'introduction √† ReasonML, pour en d√©couvrir un peu plus je vous invite √† aller lire la <a href=\"https://reasonml.github.io/\">documentation officielle</a>. On verra dans les prochains articles comment fonctionne <a href=\"https://reasonml.github.io/reason-react\">ReasonReact</a> (les bindings Reason vers React, avec quelques petites features sympathiques en plus), et comment l'adopter incr√©mentalement dans sa codebase pour avoir du code plus s√ªr, et <em>(spoilers)</em>, plus rapide que si vous l'√©criviez √† la main.</p>\n<p>Bisous bisous.</p>\n","rawBody":"\nLes bugs c'est chiant, surtout quand on sait qu'on aurait pu les √©viter. Avec JavaScript, c'est plus facile d'en avoir que de les √©viter.\n\nJavaScript, on ne peut pas y √©chapper parce que c'est partout, parce que c'est le langage de programmation le plus utilis√© sur Terre, et parce que c'est le seul truc qui (pour l'instant) tourne nativement dans le navigateur. Et puis c'est pas si mal, c'est facile de l'apprendre en bidouillant un peu, c'est tr√®s permissif et pas trop frustrant pour d√©buter.\n\nLe probl√®me c'est que c'est facile d'en faire, mais c'est tr√®s dur d'en faire **bien** (moins que CSS, mais quand m√™me). On s'est tous d√©j√† retrouv√© avec `undefined is not a function`, `null is not an object` ou un bon gros `[object Object]` qui tra√Æne dans la console.\n\n## Pourquoi est-ce que c'est comme √ßa ?\n\nJavaScript est un langage dynamiquement et faiblement typ√©, ce qui veut dire :\n- qu'une fonction ne sait pas ce qu'elle prend ou retourne comme type\nd'arguments, c'est √† vous de g√©rer\n- que le programme n'en a aucune id√©e non plus tant qu'il n'execute pas\nla portion de code\n\nTout √ßa fait qu'il est tr√®s difficile de faire confiance √† du code JavaScript.\n\n<figure>\n<img src=\"./js.png\" alt=\"js\" />\n<figcaption>Source: MIT</figcaption>\n</figure>\n\nIl existe Flow et TypeScript (dont on a parl√© dans un [pr√©c√©dent article](/fr/articles/js/flow/) et un [podcast](fr/articles/podcast/3/)), deux projets qui permettent d'apporter du typage statique pour s√©curiser son code. Ils contraignent votre usage de JavaScript, mais devront toujours se battre contre sa permissivit√©.\n\n√áa revient au final √† coller des rustines sur vos pneus avant d'aller rouler sur des clous, √ßa va vous prot√©ger un peu, mais √ßa reste de base pas bien malin d'aller rouler sur des clous.\n\nIl existe des langages qui ont la judicieuse id√©e de balayer la route pour virer les clous avant d'y aller : les langages typ√©s fortement et statiquement (10 points pour Gryffondor pour cette m√©taphore fil√©e).\n\nOCaml est un de ces langages. Il est de la famille ML et a √©t√© cr√©√© en France dans les ann√©es 90. Il est √† peu pr√®s aussi √¢g√© que JavaScript mais est beaucoup plus sage. Il est certes fortement et statiquement typ√©, mais il inf√®re la plupart des types du programme (ce qui veut dire que vous n'avez pas √† renseigner les types partout, il va l'extrapoler d√®s qu'il le peut). En bonus, il poss√®de de [bonnes data-structures](https://ocaml.org/learn/tutorials/comparison_of_standard_containers.html).\n\nSeulement voil√†, OCaml, comme beaucoup de langages fonctionnels n'a pas vraiment mis l'accent sur l'accessibilit√© pour les d√©butants, et a une syntaxe qu'on peut pour le moins qualifier de pas tr√®s friendly: elle n'a rien de bien mal, mais mettez quelqu'un qui vient de JS/PHP/Java devant, √ßa va pas lui causer des masses:\n\n```ocaml\nlet rec qsort = fun value ->\n  match value with\n   | [] -> []\n   | pivot :: rest ->\n       let is_less x = x < pivot in\n       let left, right = List.partition is_less rest in\n       qsort left @ [pivot] @ qsort right;;\n```\n\n<figure>\n<img src=\"./giphy.gif\" alt=\"\" />\n<figcaption>fig. 1: dev JS devant du code OCaml</figcaption>\n</figure>\n\nC'est l√† qu'intervient Reason, un projet initi√© par [le cr√©ateur de React](https://twitter.com/jordwalke). Les premi√®res it√©rations de React √©taient d'ailleurs cod√©es dans un langage cousin de OCaml, le SML.\n\nC'est en gros:\n\n- OCaml\n- avec une syntaxe *beginner-friendly*\n- avec un tooling le rendant plus simple √† utiliser\n- qui peut compiler vers JavaScript et de multiples plateformes\n\nAvec son type system, OCaml propose un langage *safe-by-design*, chose que m√™me avec une palanqu√©e d'outils, on ne peut pas atteindre avec JavaScript.\n\nLe langage propose par d√©faut une approche fonctionnelle et immutable, mais permet cependant de choisir d'utiliser des structures mutables et de l'orient√© objet au besoin.\n\n## Le langage\n\nReason comporte plus de types de primitifs que JavaScript:\n\n```reason\n/* pas un gros \"number\" fourre tout, magique */\n1 /* int */\n1.0 /* float */\n/* un caract√®re est d'un type diff√©rent de string */\n\"foo\" /* string */\n'a' /* char */\n/* on trouve list ET array, chacun peut √™tre utilis√© pour diff√©rents cas */\n[1, 2, 3] /* list */\n[| 1, 2, 3 |] /* array */\n/* pas de null, mais des valeurs de type `option` qui contiennent\n  soit une valeur, soit rien */\nSome 1 /* option int */\nNone /* option int */\n```\n\nPuisqu'il est fortement typ√©, il est impossible de mixer les types comme en JavaScript, vous devrez obligatoirement les convertir:\n\n```reason\n1 + 1.0;\n/* Error:\n  This expression has type int but an expression was expected of type float */\n1 + int_of_float 1.0;\n/* - : int = 2 */\n```\n\nLa plupart des op√©rations de transformations de type primitifs vers un autre sont accessibles dans le module `Pervasives` qui contient plein de petits utilitaires bien pratiques. Toutes les fonctions de ce module sont accessibles directement dans n'importe quel de vos fichiers.\n\nLes fonctions de Reason sont beaucoup plus puissantes qu'en JavaScript:\n\n```reason\nlet add a b => a + b;\n/* int => int => int */\nadd 1 2;\n/* 3 */\nadd 1 2.0;\n/* This expression has type float but an expression was expected of type int */\n\n/* Les fonctions sont \"auto-curried\", ce qui signifie qu'une fonction\n   qui n'a pas re√ßu tous ses param√®tres retourne une nouvelle fonction\n  qui va recevoir les param√®tres manquants */\nlet addOne = add 1;\n/* int => int */\n\n/* Les fonctions peuvent avoir des param√®tres nomm√©s, optionnels et avec des valeurs par d√©faut */\nlet sayHi ::name ::punct=\"!\" () => \"Hello \" ^ name ^ punct;\n/* name::string => string */\nsayHi name::\"you\" ();\n/* \"Hello you!\" */\n/* L'ordre des arguments nomm√©s n'a pas d'importance*/\nsayHi punct::\"?\" name::\"you\"  ();\n/* \"Hello you?\" */\n```\n\nPour d√©finir l'√©quivalent d'un *plain-object* JavaScript en Reason, on utilise des records:\n\n```reason\n/* On doit typer les records */\ntype user = {\n  username: string,\n  age: int\n};\n\n/* Les records ont un nombre de cl√©s fini, vous ne pouvez pas en\n  ommettre une ou en mettre une en trop */\nlet user = { username: \"Bob\" };\n/* Error: Some record fields are undefined: age */\n\nlet user = { username: \"Bob\", age: 20 };\n\n/* Les records sont immutables par d√©faut */\nlet olderUser = {...user, age: user.age + 1 };\n```\n\nReason poss√®de un syst√®me de module tr√®s puissant: par d√©faut, chaque fichier de votre codebase est un module, mais vous pouvez √©galement d√©clarer des modules *dans* un module.\n\n```reason\nmodule User = {\n  type t = {\n    id: string,\n    username: string,\n    email: option string\n  };\n  let make ::id ::username ::email => {id, username, email};\n  let sayHi user => \"Hello \" ^ user.username ^ \"!\";\n};\n\n/* Pour utiliser un module, tapez son nom, tout simplement */\nUser.make id::\"0\" username::\"bloodyowl\" email::None\n  /* (ah oui, le pipe existe d√©j√† ici, pas besoin d'attendre ES2050)*/\n  |> User.sayHi\n  |> print_endline;\n/* \"Hello bloodyowl\" */\n\n/* On peut √©galement rendre toutes les valeurs d'un module accessibles localement */\nUser.(\n  make id::\"0\" username::\"bloodyowl\" email::None\n    |> sayHi\n    |> print_endline\n);\n\n/* Carr√©ment les rendre accessibles globalement dans le module */\nopen User;\n\nmake id::\"0\" username::\"bloodyowl\" email::None\n  |> sayHi\n  |> print_endline;\n\n/* Ou m√™me √©tendre un module statiquement et proprement,\n  √ßa vous parle √ßa, Prototype et MooTools ?! */\nmodule UserThatCanSayBye = {\n  include User;\n  let sayBye user => \"Bye \" ^ user.username ^ \"!\";\n};\n```\n\nIl existe √©galement des functors, qui sont des sortes de fonctions retournant des modules √† partir d'autres modules, mais on ne l'abordera pas dans cet article.\n\nReason poss√®de √©galement des variants, il s'agit de types pouvant avoir diff√©rents cas. Prenons l'exemple d'un message de chat:\n\n```reason\ntype image = {url: string, width: int, height: int};\n\n/* chaque cas du variant peut prendre des param√®tres */\ntype message =\n  | String string /* soit une cha√Æne de caract√®res */\n  | Image image /* soit une image */\n  | Emoji string; /* soit un gros emoji */\n\nlet stringMessage = String \"Hello\"; /* On cr√©e la valeur avec son constructeur */\nlet imageMessage = Image {url: \"https://fakeimg.pl/300x300\", width: 300, height: 300};\nlet emojiMessage = Emoji {js|üê´|js}; /* Quand la string contient de caract√®res unicode,\n  on doit utiliser {js|votre string|js} */\n```\n\nIci, notre type `message` est bien d√©limit√©, et ses valeurs ne peuvent √™tre que celles que l'on a d√©fini.\n\nPour utiliser les valeurs d'un variant, on peut les extraire √† l'aide de `switch`, qui va *pattern-matcher* pour nous permettre d'identifier et d'extraire les valeurs.\n\n```reason\n/* Petit bonus, l'exemple utilise ReasonReact, mais on d√©taillera √ßa dans un prochain article */\nlet component = ReasonReact.statelessComponent \"ChatMessage\";\n\nlet make ::message _children => {\n  ...component,\n  render: fun _ => {\n    <div>\n      (switch message {\n        | String value => ReasonReact.stringToElement value\n        | Image {url: src, width, height} => <img width height src />\n        /* Si par m√©garde j'oublie un cas possible dans un switch, je vais avoir un joli warning du\n          compiler qui me dira:\n            This pattern-matching is not exhaustive.\n            Here is an example of a value that is not matched:\n              Emoji\n        */\n        | Emoji value =>\n          <div style=(ReactDOMRe.Style.make fontSize::\"40px\" ())>\n            (ReasonReact.stringToElement value)\n          </div>\n      })\n    </div>\n  }\n};\n```\n\nEn Reason, les *let bindings* ont automatiquement le block parent comme scope, on peut du coup √©crire des choses comme ceci :\n\n```reason\nlet value = {\n  let a = 1;\n  let b = 2;\n  a + b; /* la derni√®re expression est toujours retourn√©e par d√©faut */\n};\n/* let value : int = 3 */\na\n/* Error: Unbound value a */                                                 \n```\n\nVoil√† pour l'introduction √† ReasonML, pour en d√©couvrir un peu plus je vous invite √† aller lire la [documentation officielle](https://reasonml.github.io/). On verra dans les prochains articles comment fonctionne [ReasonReact](https://reasonml.github.io/reason-react) (les bindings Reason vers React, avec quelques petites features sympathiques en plus), et comment l'adopter incr√©mentalement dans sa codebase pour avoir du code plus s√ªr, et *(spoilers)*, plus rapide que si vous l'√©criviez √† la main.\n\nBisous bisous.\n","__filename":"fr/articles/reason/introduction-reason/index.md","__url":"/fr/articles/reason/introduction-reason/","__resourceUrl":"/fr/articles/reason/introduction-reason/index.html","__dataUrl":"/fr/articles/reason/introduction-reason/index.html.cad16ff69aefd91c144328d6585d52e5.json"}